package me.cooljwb.vulnerabilitypatcher.events;

import java.util.HashMap;
import java.util.UUID;
import me.cooljwb.vulnerabilitypatcher.patches.Patches;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.Chest;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerLoginEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;

public class DisconnectionAid extends Patches implements Listener {

    HashMap<UUID, Long> antiDisconnect = new HashMap<>();

    @EventHandler
    public void onPlayerJoinEvent(PlayerLoginEvent event) {
        antiDisconnect.put(event.getPlayer().getUniqueId(), System.currentTimeMillis());
    }

    @EventHandler
    public void onPlayerLeftEvent(PlayerQuitEvent event) {
        if(antiDisconnect.containsKey(event.getPlayer().getUniqueId()) && (System.currentTimeMillis() - antiDisconnect.get(event.getPlayer().getUniqueId())) <= 500) {
            event.getPlayer().teleport(getSafeLocation(event.getPlayer().getLocation())); // Teleport player to safe location.

            Inventory playerInv = event.getPlayer().getInventory();
            Block block = event.getPlayer().getWorld().getBlockAt(event.getPlayer().getLocation());
            block.setType(Material.CHEST);

            for(ItemStack item : playerInv.getContents()) {
                if(item != null && item.getType() != Material.AIR) {
                    ((Chest) block.getState()).getBlockInventory().addItem(item);
                }
                playerInv.clear();
            }
        }
        antiDisconnect.put(event.getPlayer().getUniqueId(), System.currentTimeMillis());
    }

    /**
     * Makes sure that the location is safe to be teleported to.
     * @param currentLocation The current location of the entity.
     * @return The new safe location.
     */
    public Location getSafeLocation(Location currentLocation) {
        double x = currentLocation.getX();
        double z = currentLocation.getZ();

        if(x + 10000 > 29999900) {
            currentLocation.setX(x + (Math.random() * 50000 + 10000));
        }
        else {
            currentLocation.setX(x - (Math.random() * 50000 + 10000));
        }

        if(z + 10000 > 29999900) {
            currentLocation.setZ(z + (Math.random() * 50000 + 10000));
        }
        else {
            currentLocation.setZ(z - (Math.random() * 50000 + 10000));
        }

        if(currentLocation.getWorld().getHighestBlockYAt(currentLocation) < 250) {
            currentLocation.setY(currentLocation.getWorld().getHighestBlockYAt(currentLocation)); // Set Y to highest location.
        }
        else {
            currentLocation.setX(29999990);
            currentLocation.setZ(29999990);
            currentLocation.setY(100);
        }

        return currentLocation; // Returns modified current location.
    }
}
